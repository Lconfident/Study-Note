## 第1章 开始

### 编写一个简单的C++程序

每个C++程序有一个或多个函数（**function**)，但必须包含**main函数**，操作系统会通过调用main来运行C++程序。

**一个函数的定义：**

- 返回类型（**return type**）
- 函数名（**function name**)
- 形参列表（**parameter list**）
- 函数体（**function body**)

```c++
int main (){
    return 0;
}
```

> - main的形参列表是空的
> - main函数的返回类型必须是 **int** 
> - 最后一部分是函数体，以左花括号开始，以右花括号结束的语句块

> 类型是程序设计的最基本的概念之一，一种类型不仅定义了数据元素的内容，还定义了这类数据上可以进行的运算。
>
> 程序所处理的数据都保存在变量中，而每个变量都有自己的类型。
> 即<u>v具有类型T</u>或<u>v是一个T类型变量</u>

**编译、运行程序**

* 程序源文件：程序源码存储在一个或多个文件中，程序文件通常称为**源文件**（source file）

### 初识输入、输出

C++并未定义任何输入、输出（IO）语句，取而代之，包含了一个全面的标准库（standard library）来提供IO机制（以及其他设施）

> **iostream**库：有两个基础类型 **istream** 和 **ostream** ，分别表示输入流和输出流。
>
> 一个流就是一个字符序列，是从IO设备读出或写入IO设备的。
>
> 术语`流`想要表达的是，随着时间的推移，字符是顺序生成或消耗的

**标准输入输出对象**

标准库定义了4个IO对象

> 为了处理输入，我们使用一个名为 **`cin`**（发音为 see-in）的 `istream` 类型的对象，这个对象也被称作**标准输入**

> 为了输出，我们使用一个名为 **`cout`**（发音为see-out）的 `ostream` 类型的对象，此对象也被称作**标准输出**

> 标准库还定义了其他两个 `ostream` 对象，名为 **`cerr`** ,**`clog`**（发音分别是  see-err 和 see-log）
>
> 我们通常用 cerr 来输出警告和错误信息，因此它有被称作**标准错误**（standard error），而 clog 用来输出程序运行时的一般性信息

**一个使用IO库的函数**

>  提示用户输入两个数，然后输出它们的和

```c++
#include <iostream>
int main() {
	std::cout << "Enter two number:" << std::endl;
	int v1 = 0, v2 = 0;
	std::cin >> v1 >> v2;
	std::cout << "The sum of" << v1 << "and" << v2
		<< "is" << v1 + v2 << std::endl;
	return 0;
}
```

> 这个程序开始时在用户屏幕打印
>
> `Enter two numbers`
>
> 然后等待用户输入。如果输入
>
> `3 7`
>
> 然后键入一个回车，则程序产生如下输出：
>
> `The sum of 3 and 7 is 10`

**程序第一行**

> `#include <iostream>`
>
> 告诉编译器我们想要使用**iostream库**。
> 尖括号中的名字（本例是iostream）指出了一个**头文件**（header）。
> 每个使用标准库设施的程序都必须包含相关的头文件。
> 通常情况下，#include指令和头文件写在源文件的开始位置

> > 头文件：指在C/C++编程中，可以写在程序里面，以#include 的形式包含的文件
>
> > 库文件：将一系列的源文件进行编译打包，形成的二进制文件包，其中封装着函数接口，在编程中可以由其它源文件调用。库文件可分为静态库和动态库两种。
>
> > 二者的区别为：
> >
> > 1. 头文件是**文本文件**，是可供阅读的 ；库文件是**二进制文件**，不可直接阅读。
> > 2. 头文件在**编译中**使用；库文件在**链接中**使用。
> > 3. 头文件中是函数或定义的声明，及少量内联函数的使用，一般不包含非静态函数实现；库文件中包含函数的实现。
> > 4. 头文件是手动编写的，库文件是编译生成的。
>
> > 二者也有联系：
> >
> > 1. 虽然没有规定调用库函数必须引用头文件，但一般约定，当调用库函数的时候需要引用接口函数所在的头文件。
> > 2. 一个库文件均有一组头文件与其对应。
> > 3. 库文件和对应头文件应为同一个。
> > 4. 作者必须保证头文件中所声明的函数类型及参数列表，与库文件中的实现是相同的。

**向流写入数据**

> main的函数体第一条语句执行了一个**表达式**（expression），使用了**输出运算符** `<<` 在**标准输出**上打印消息：
>
> `std::cout << "Enter two numbers:" << std::endl;`
>
> <<运算符接受两个运算对象：
>
> 左侧的运算对象必须是一个 `ostream` 库的对象
>
> 右侧的运算对象是要打印的值
>
> 此运算就是要将给定的值写到给定的 `ostream` 对象中，计算结果就是左侧运算对象

> 我们的输出运算符使用了两次<<运算符。
>
> 等价于
>
> (`std::cout << "Enter two numbers:"`)`<< std::endl;` 
>
> 又因为每个运算符的左侧运算对象都是相同的，`std::cout`，我们也可以用两条语句生成相同的输出：
>
> `std::cout << "Enter two numbers:":`
>
> `std:cout << std::endl;`
>
> 第一个输出运算符给用户打印了一条消息。这个消息是一个**字符串字面值常量**（string literal），是用一对双引号包围的字符序列。在双引号中的文本被打印到标准输出。
>
> 第二个运算符打印`endl`，这是一个被称作为**操作符**的特殊值。写入`endl`的效果是<u>结束当前行</u>，并将与设备关联的**缓冲区**（buffer）中的内容刷到设备中。缓冲刷新操作可以保证，到目前为止程序所产生的所有输出都被真正写入输入输出流中，而不是仅停留在内存中等待写入流。

**使用标准库中的名字**

> 这个程序中使用了`std::cout`和`std::endl`，而不是直接的`cout`和`endl`。
>
> 前缀`std::`指出名字`cout`和`endl`是定义在名为**`std`**的**命名空间**（namespace）中的。
>
> 命名空间可以帮助我们避免不经意的名字定义冲突，以及使用库中相同名字导致的冲突。
>
> 标准库所有的名字都命名在命名空间`std`中
>
> 但是通过命名空间使用标准库有一个副作用：
>
> 当使用标准库的一个名字时，必须显式说明我们像使用命名空间`std`中的名字。例如，需要写出`std::count`，通过使用**作用域运算符** `::`来指出我们想使用定义在命名空间`std`中的`cout`。之后会给出一个更简单的访问标准库中名字的方法。

**从流中读取数据**

> 在提示用户输入数据后，我们希望读入用户的输入。首先定义两个名为`v1`和`v2`的变量（variable)来保存输入：
>
> `int v1 = 0, v2 = 0;`
>
> 我们将这两个变量定义为`int`类型，int是一种内置类型，用来表示整数。同时将它们**初始化**（initialize）为0。初始化一个变量，就是在变量创建的同时为它赋予一个值。
>
> 下一条语句是
>
> `std::cin >> v1 >> v2;`
>
> 它读入输入数据。**输入运算符**`>>`与输出运算符类似，它接受一个`istream`作为其左侧运算对象，接受一个对象作为其右侧运算对象。它从给定的`istream`读入数据，并存入给定对象中。
>
> 输入运算符返回其左侧运算对象作为其计算结果。因此等价于
>
> (`std::cin >> v1`)`>> v2;`
>
> 也与上面的例子一样，同样等价于
>
> `std::cin >> v1;`
>
> `std::cin >> v2;`

**完成程序**

> 剩下的就是打印计算机结果了：
>
> `std::cout << "The sum of " << v1 << " and " << v2 << " is " << v1+v2 << std::endl;`

> 这条语句虽然比提示语句更长，但原理上是一样的，它将每个运算对象打印在标准输出上。本例最大的特别之处在于，运算对象并不都是相同类型的值。某些运算对象是字符串字面值常量，其他运算对象是int值。

### 注释简介

**C++注释的种类**

- 单行注释

  > 单行注释以双斜线 `//`开始，以换行符结束。当前行双斜线右侧的所有内容都会被编译器忽略，这种注释可以包含任何文本，包括额外的双斜线

- 界定符注释

  >  这种注释继承自C语言的两个界定符 `/*` 和 `*/` ,可包含处`*/` 外的任意内容

> **注释界定符不能嵌套**

### 控制流

#### while语句

> while语句反复执行一段代码，直至给定条件为假为止。

认识几个运算符：

> `<=` : 小于等于运算符
>
> `+=` : 复合赋值运算符
>
> `++` : 前缀递增运算符

#### for语句

```c++
for (int val = 1; val <=10; val++){
    sum += val;
}
```

> 简要描述一下for循环的总体执行过程：
>
> 1. 创建变量val，将其初始化为1
> 2. 检测val是否小于等于10。若ture，执行for循环体；若false，退出循环，继续执行for循环体之后的语句
> 3. 将val的值增加1
> 4. 重复步骤2，，只要条件为真就执行剩余步骤

#### 读取数量不定的输入数据

在前一节中，我们编写了程序实现了1和10这10个整数求和，扩展这个程序很自然的方向是实现对用户输入的一组数求和。

在这种情况下，我们预先不知道要对多少个数求和，这就需要不断读取直至没有新的输入为止。

```c++
#include <iostream>
int main() {
	int sum = 0, value = 0;
	//读取数据直到遇到文件尾，计算所有读入的值的和
	while (std::cin >> value) {
		sum += value;
	}
	std::cout << "Sum is:" << sum << std::endl;
	return 0;
}
```

> 如果我们输入
>
> `3 4 5 6`
>
> 则程序输出
>
> `Sum is: 18`

> `main` 的首行定义了两个名为 `sum` 和 `value` 的 `int` 变量，均初始化为0。我们使用 `value` 保存用户输入的每个数，数据读取操作是在 `while`的循环操作中完成的：
>
> `while (std::cin >> value)`
>
> `while` 循环条件的求值就是执行表达式：
>
> `std::cin >> value`
>
> 此表达式从标准输入读取下一个数，保存在 `value` 中。输出运算符返回其左侧运算对象，在本例中是 `std::cin` ，因此，此循环条件实际上检测的是 `std::cin` 。

> 当我们使用一个 `iostream` 对象作为条件时，其效果是检测流的状态。
>
> 如果流是有效的，即流未遇到错误，那么检测成功。
>
> 当遇到文件结束符或遇到一个无效输入时（例如读入的值不是一个整数）， `iostream` 对象的状态会变为无效。处于无效状态的`iostream`对象会使条件为假。

> **从键盘输入文件结束符：**
>
> Windows系统中，输入文件结束符的方法：<kbd>Ctrl</kbd> + <kbd>Z</kbd>,然后按 <kbd>Enter</kbd>
>
> UNIX系统中，输入文件结束符的方法：<kbd>Ctrl</kbd> + <kbd>D</kbd>

#### if 语句

> C++使用 `=` 来赋值，用 `==` 作为相等运算符。

### 类简介

C++特性：如何定义一个数据结构（data structure）来表示数据

C++中可以通过定义一个**类**（class）来定义自己的数据结构

为了使用类，我们需要了解三个事情：

+ 类名是什么？
+ 它是在哪里定义的？
+ 它是支持什么操作？

对于书店程序，我们假定类名为`Sale_item`，头文件`Sale_item.h`中已经定义了这个类

因此，为了使用标准库设施，我们必须包含相关的头文件。类似的，我们也需要使用头文件来访问为自己的应用程序所定义的类。

习惯上，头文件根据其中定义的类的名字来命名。我们通常使用 `.h` 作为头文件的后缀，标准库头文件通常不带后缀。

#### Sales_item类

Sales_Item 类的作用是表示一本书的总销售额、售出册数和平均售价。

> 我们现在不关心这些数据如何存储、如何计算。为了使用一个类，我们不必关心它是如何实现的，只需直到类对象执行什么操作。

> 每个类实际上都定义了一个新的类型，其类型名就是类名。因此，我们的`Sales_item` 类定义了一个名为 `Sales_item` 的类型。
>
> 当我们写下如下语句：
>
> `Sales_item item;`
>
> 是想表达 `item` 是一个 `Sales_item` 类型的对象。我们通常将“一个`Sales_item`类型的对象”简单说成“一个`Sales_item`对象”，或更简单的“一个`Sales_item` ”

> 除了可以定义`Sales_item`类型的变量外，我们还可以：
>
> + 调用一个名为`isbn`的函数从一个`Sales_item`对象中提取ISBN书号
> + 用输入运算符`>>`和输出运算符`<<`读、写`Sales_item`类型的对象
> + 用赋值运算符`=`将一个`Sales_item`对象的值赋予另一个`Sales_item`对象
> + 用加法运算符`+`将两个`Sales_item`对象相加。两个对象必须表示同一本书（相同的ISBN）。加法结果是一个新的`Sales_item`对象，其IBSN与两个运算对象相同，而其总销售额和售出册数则是两个运算对象的对应值之和
> + 使用复合赋值运算符`+=`将一个`Sales_item`对象加到另一个对象上

> 一般而言，类的作者决定了类类型对象上可以使用的所有操作。

**读取`Sales_item`**

> 既然已经知道可以对`Sales_item`对象执行哪些操作，我们就可以编写使用类的程序了。

例如，下面的程序从标准输入读入数据，存入一个`Sales_item`对象中，然后将`Sales_item`内容写回到标准输出：

```c++
#include <iostream>
#include "Sales_item.h"
int main() {
	Sales_item book;
	//读入ISBN号、售出的册数以及销售价格
	std::cin >> book;
	//写入ISBN号、售出的册数、总销售额和平均价格
	std::cout << book << std::endl;
	return 0;
}
```

> 如果输入：
>
> `0-201-70353-x 4 24.99`
>
> 则输出为：
>
> `0-201-70353-x 4 99.96 24.99`
>
> 输出表示我们以每本`24.99`美元的价格售出了4册书，而输出告诉总售出册数为`4`，总销售额为`99.96`美元，而每册书的平均销售价格为`24.99`美元。

> 此程序以两个`#include`指令开始，其中一个使用了新的形式。
>
> 包含来自标准库的头文件时，也应该用尖括号`<>`包围头文件名
>
> 对于不属于标准库的头文件，则用双引号`'' ''`包围

**Sales_item 对象的加法**

下面的例子更有意思，将两个`Sales_item`对象相加：

```c++
#include <iostream>
#include "Sales_item.h"
int main() {
	Sales_item item1,item2;
	std::cin >> item1 >> item2; //交易一对交易记录
	std::cout << item1 + item2 << std::endl; //打印它们的和
	return 0;
}
```

> 如果输入如下内容：
>
> `0-201-78345-x 3 20.00`
>
> `0-201-78345-x 2 25.00`
>
> 则输出：
>
> `0-201-78345-x 5 110 22`

> 此程序开始包含了`Sales_item` 和 `iostream` 两个头文件，然后定义了两个`Sales_item` 对象来保存销售记录 。我们从标准输入读取数据，存入两个对象中，输出表达式完成运算并打印结果。
>
> 两个对象，我们用了一个全新的“和”概念——两个`Sales_item`对象的成员对应相加的结果

#### 使用文件重定向

> 当你测试时，反复从键盘敲入这些销售记录作为程序的输入，是非常枯燥的，大部分的操作系统支持文件重定向的，这种机制允许我们将标准输入和标准输出与命名文件关联起来：
>
> `$ addItems <infile> outfile`
>
> 假定`$`是操作系统提示符，我们的加法程序已经编译为名为`addItems.exe` 的可执行文件（在UNIX中是`addItem`），则上述命令会从一个名为`infile`的文件读取销售记录，并将输出结果写入到一个名为`oufile`的文件中，这两个文件都位于当前目录中

**初识成员函数**

将两个`Sales_item`对象相加的程序相加的程序首先应该检查两个对象是否具有相同的ISBN，方法如下：

```c++
#include <iostream>
#include "Sales_item.h"
int main() {
	Sales_item item1,item2;
	std::cin >> item1 >> item2; //交易一对交易记录
	//首先检查它们是否表示相同的书
	if (item1.isbn() == item2.isbn()) {
		std::cout << item1 + item2 << std::endl;
		return 0;//表示成功
	}
	else {
		std::cout << "Data must refer to same ISBN"
			<< std::endl;
		return -1;//表示失败
	}
}
```

**什么是成员函数**

> 这个`if`语句的检测条件
>
> `item1.isbn() == item2.isbn()`
>
> 调用名为`isbn`的成员函数（member function）。
>
> 成员函数是定义为<u>类的一部分</u>的函数，有时也叫做**方法**（method）

> 我们通常以一个类对象的名义来调用成员函数。
>
> 例如，上述相等表达式左侧运算对象的第一部分
>
> `item1.isbn()`
>
> 使用点运算符`.`来表达我们需要”名为`item1`的对象的`isbn`成员，其左侧必须是一个类的对象，右侧必须是该类的一个成员名，运算结果就是指定对象的指定成员
>
> 当用点运算符`.`访问一个成员函数时，通常调用该函数，我们使用**调用运算符**`()` 来调用一个函数，调用运算符是一对圆括号，里面放置实参（arguement）列表（可能为空）。成员函数`isbn()` 并不接受参数，因此为：
>
> `item1.isbn()`
>
> 调用名为`item1`的对象的成员函数`isbn`，此函数返回`item1`中保存ISBN书号

### 术语表

* **参数**（实参，argument）向函数传递的值
* **赋值**（assignment）抹去一个对象的当前值，用一个新值取代
* **程序块**（block）零条或多条语句的序列，用花括号包围
* **缓冲区**（buffer）一个存储区域，用于保存数据。IO设施通常将输入（或输出）数据保存在一个缓冲区中，读写缓冲区的动作与程序中的动作不相干。我们可以显式地刷新输出缓冲，以便将缓冲区中的数据写入输出设备。默认情况下，读cin会刷新cout；非正常终止程序时也会刷新cout
* **内置类型**（built-in type）由语言定义的类型，如int
* **Cerr**一个ostream对象，关联到标准错误，通常写入到标准输出相同的设备。默认情况下，写到cerr的数据是不缓冲的。cerr通常用于输出错误信息或其他不属于程序正常逻辑的输出内容
* **clog**一个ostream对象，关联到标准错误。默认情况下，写到clog的数据是被缓冲的。clog通常用于报告程序的执行信息，存入一个日志文件中
* **字符串字面值常量**（character string literal）术语stringliteral的另一种叫法
* **cin**一个istream对象，用来从标准输入读取对象
* **类**（class）一种定义自己的数据结构及其相关操作的机制。标准库类型中，如istream、ostream都是类
* **类类型**（class type）类定义的类型
* **注释**（comment）被编译器忽略的程序文本，有单行注释和界定符对注释两种
* **条件**（condition）求值结果为真或假的表达式，通常值0表示假，非零值表示真
* **cout**一个ostream对象，用于数据写入标准输出，通常用于程序的正常输出内容
* **数据结构**（data structure)数据及其上所允许操作的一种逻辑组合
* **编辑-编译-调式**（edit-compile-debug）使程序能正确执行的过程
* **文件结束符**（end-of-file）系统指定的标识，指出文件再无更多数据了，Windows<kbd>Ctrl</kbd> + <kbd>Z</kbd>
* **操作符**（manipulator）对象，如`std::endl`，在读写流的时候用来操纵“流”本身
* **命名空间**（namespace）将库定义的名字放在一个单一位置的机制，C++标准库定义的名字在命名空间std中
* **形参列表**（parameter list）函数定义的一部分，指出调用函数时可以使用什么样的实参，可能为空列表
* **标准错误**（standard error）输出流，用于报告错误
* **标准库**（standard library）一个类型和函数的集合
* `::`运算符（`::`operator）作用域运算符，其用处之一是访问命名空间的名字
* `#include`头文件包含指令，使头文件中代码可被程序执行

# 第Ⅰ部分 C++基础

## 第2章 变量与变量类型

### 基本内置类型

包括**算术类型**（arithmethic type）和**空类型**（void）

 算术类型

分为两类：整形和浮点型

| 类型        | 含义           | 最小尺寸     |
| ----------- | -------------- | ------------ |
| bool        | 布尔类型       | 未定义       |
| char        | 字符           | 8位          |
| wchar_t     | 宽字符         | 16位         |
| char16_t    | Unicode字符    | 16位         |
| char32_t    | Unicode字符    | 32位         |
| short       | 短整型         | 16位         |
| int         | 整型           | 16位         |
| long        | 长整型         | 32位         |
| long long   | 长整型         | 34位         |
| float       | 单精度浮点数   | 6位有效数字  |
| double      | 双精度浮点数   | 10位有效数字 |
| long double | 扩展精度浮点数 | 10位有效数字 |

**带符号类型和无符号类型**

> 除去布尔类型和扩展的字符型以外，其他整形可以划分为带符号（signed）的和无符号（unsigned）的
>
> 带符号类型可以表示正数、负数或0
>
> 无符号类型仅能表示大于等于0的值

**转义序列**

| 类型       | 表示 |
| ---------- | ---- |
| 换行符     | `\n` |
| 横向制表符 | `\t` |
| 回车符     | `\r` |
| 纵向制表符 | `\v` |
| 退格符     | `\b` |
| 进纸符     | `\f` |

### 变量

> 初始化不是赋值，初始化的含义是创建变量时赋予一个初始值，而赋值的含义是把对象的当前值擦除，用一个新值来替代

> 变量声明只规定了变量的类型和名字
>
> 定义还申请了内存空间，也可能赋予一个初始值
>
> 如果想声明一个变量，加关键字`extern`
>
> ```c++
> extern int i;//声明i
> int i;//定义i
> extern int i = 1;//定义
> ```

> 变量能只能被定义一次，但可以被声明多次。
>
> 多个文件想要使用同一变量，就必须声明和定义分离，定义只能出现在一个文件中，而用到这个变量的文件必须对其声明，但绝对不能重复定义

> 标识符：字母，数字，下划线组成，必须以字母或下划线开头
>
> 作用域：全局作用域|块作用域

### 复合类型

>  基于其他类型定义的类型，有引用、指针等

**引用**

> C++中新增一种引用：“右值引用”，主要用于内置类。严格来说，当我们说起引用（reference）时，指的是“左值引用”

引用（reference）为对象起了另外一个名字，引用类型引用(refers to)另一种类型

通常将声明符写成`&d`的形式来定义引用类型，其中`d`是声明的变量名

```c++
int ival = 1024;
int &reival = ival;//reival指向ival（是ival的另一个名字）
int &reival2;//报错，y
```

> 引用定义时，程序把引用和它的初始值对象**绑定**在一起，而不是将初始值拷贝给引用

**引用即别名**

引用并非对象，相反的，它只是为**一个已经存在的对象**所起的**另外一个名字**

* 为引用赋值，实际上就是把值赋给与引用绑定的对象
* 获取引用的值，实际上就是获取与引用绑定的对象的值
* 以引用作为初始值，实际上就是以与引用绑定的对象作为初始值

> 因为引用不是一个对象，而引用是基于一个对象才能定义的，所以不能定义引用的引用



**引用的定义**

以符号`&`开头

所有的引用的类型都要与它要绑定的对象严格匹配，而且引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起

----

**指针**

与引用类似，指针也实现了对其他对象的间接访问

但是指针本身就是一个对象，能赋值和拷贝，而且，它可以指向不同的对象

指针在定义时不用赋值，它在没有被初始化时，也有一个不确定的值

```c++
double dp,*dp2;//dp是double型对象，dp2是指向double型对象的指针
int *p;      //定义p是指向int型的指针
```

**获取对象的地址**

指针存放某个对象的地址，取地址符`&`

```c++
int ival = 3;
int *p = &ival;  //p存放变量ival的地址或者说p是指向变量ival的指针
```

第二条语句把`p`定义成一个指向`int`型的指针，然后初始化`p`令其指向名为 `ival`的`int`对象

> 因为引用不是对象，没有实际的地址，所以不能定义指向引用的指针
>
> 声明语句中指针的类型和实际上指向的对象类型必须匹配

```c++
double dval;
double *pd = &dval; //对，初始值是double 型对象的地址
double *pd2 = pd;   //对，初始值是double 型对象的指针
```

**指针值**

指针的值（即地址）有4种状态：

1. 指向一个对象

2. 指向紧邻对象所占空间的下一个位置

3. 空指针，意味着指针没有指向任何对象

4. 无效指针，也就是上述情况之外的其他值

   2、3、4使用都有限制访问指针的行为不被允许



**利用指针访问对象**

解引用符`*`

```c++
int ival = 42;
int *p = &ival;//p存着ival的地址
cout << *p;    //由符号*得到指针p所指的对象，输出42
```

> 某些符号的多重应用
>
> ```c++
> int i = 42;
> int &r = i;//&紧随类型名出现，因此是声明的一部分，r是一个引用
> int *p;    //*紧随类型名出现，因此是声明的一部分，p是一个指针
> p = &i;    //&出现在表达式中，是一个取地址符
> *p = i;    //*出现在表达式中，是一个解引用符
> int &r2 = *p;//&是声明的一部分，*是一个解引用符
> ```

**空指针**

不指向任何对象

生成空指针的办法：

1. `int *p1 = nullptr;`（推荐使用）

   > 用字面值`nullptr`来初始化指针，可以转换成任意其他类型的指针类型

2. `int *p2 = 0;`

   > 初始化为字面值0来生成空指针

3. `#include <cstdlib> ... int *p3 = NULL;`

   > 名为NULL的预处理量来给指针赋值，这个变量在头文件`cstdlib`中定义，它的值为0

----

**赋值与指针**

引用：本身不是一个对象，一旦定义了，就绑定一个对象，之后每次使用这个引用都是访问最初绑定的那个对象

指针：给指针赋值就是让它存放一个新的地址，从而指向一个新的对象

要想搞清楚一条赋值语句到底是改变了**指针的值**还是改变了指针所指**对象的值**不太容易，但是记住**赋值永远改变**的是**等号<u>左侧的对象</u>**

```c++
int i = 1024; 
int *pi = 0;   //pi被初始化，空指针
int *pi2 = &i; //pi2被初始化，存i的地址
int *pi3;      //若pi3定义在块内，则pi3的值无法确定
pi3 = pi2;     //pi3和pi2指向同一个对象i
pi2 = 0;       //pi2不指向任何一个对象
pi = &i;       //pi的值改变了，pi指向i
*pi = 0;       //i的值改变了，指针pi并没有改变
```

**其他指针操作**

只要指针拥有一个合法值，就可以用在表达式中。

指针的值为`0`，条件取`false`;任何非`0`的指针对应条件都是`true`

**`void*`指针**

`void*`是一种特殊的指针类型，可以存放任意对象的地址。只是我们事先不清楚是什么类型的对象而已

----

**理解复合类型的声明**

前面说过，变量的定义包括一个基本数据类型和一组声明符。也就是在同一条语句中，虽然基本数据类型只有一个，但是声明符的形式却可以不同

> 好的习惯

```c++
int *p,q;
//int* p,q;//效果一样，合法但容易误导
int *a, *b;//推荐这样写
//或者这样写也可以
int* a;
int* b;
```

**指向指针的指针**

通过`*`的个数可区分指针的级别

```c++
int ival = 1024;
int *pi = &ival;//指向一个int 型的对象
int **ppi = &pi;//指向一个int 型的指针
```

套娃现场

ppi——>pi——>1024(ival)

```c++
cout << "The value of ival\n"
    << "direct value: " << ival << "\n"
    << "indirect value: " << *pi << "\n"
    << "doubly indirect value: " << **ppi
    << endl;
```

> 使用三种不同的方式输出ival的值：第一种直接输出；第二种通过int型的pi输出；第三种通过两次解引用ppi输出

**指向指针的引用**

不能定义指向引用的指针，但是可以定义指向指针的引用

```c++
int i = 42;
int *p;//p 是一个int 型指针
int *&r = p;//r 是一个对指针p 的引用，r 是p 的一个别名
r = &i;//r 引用了一个指针，因此给r 赋值也就是令p 指向i
*r = 0;//解引用r 得到i ，也就是p 指向的对象，将i 的值改为0
```

要理解`r`到底是什么，最简单的办法是从右往左阅读`r`的定义。

> 离变量名最近的是`&`，因此是一个引用，然后是`*`，说明引用的是一个指针，最后基本数据类型是`int`，说明`r`引用的是一个`int`型的指针

### `const`限定符

`const`对象一旦创建后其值无法再改变，所以`const`对象必须初始化

> **初始化和`const`**
>
> 对象的类型决定了它的操作，`const`主要的限制是不能执行改变其内容的操作。
>
> ```c++
> const int i = 42;//对，编译时初始化
> ```
>
> 
>
> 在不改变`const`对象的操作中还有一种初始化，利用一个对象去初始化另一个对象，则它们是不是`const`都无关紧要
>
> ```c++
> int i = 42;
> const int ci = i;//对，i的值拷贝给ci
> int j = ci;//对，ci的值拷贝给j
> ```
>
> 尽管`ci`是整型常量，但终究`ci`中值也还是一个整数。
>
> `ci`的常量特征只有在改变`ci`的操作时发挥作用。
>
> 当用`ci`去初始化`j`时，根本不用管谁是谁，拷贝一个对象的值并不会改变它，而一旦副本完成，新的对象就和原来的对象没什么关系了

> **默认情况下，`const`对象仅在文件内有效**
>
> 当我们写下这样的代码时，
>
> `const int bufSize = 512;`
>
> 编译器会找到所有用到`bufSize`的地方，然后用`512`替换
>
> 为了执行这个替换，编译器就必须知道这个变量的初始值
>
> 如果有多个文件，就必须保证每个用到这个变量的文件都能访问到它的初始值，这样就必须在每个用到这个变量的文件中都有对它的定义
>
> 为了支持这个用法，又同时避免对同一个变量的重复定义，默认情况下，`const`对象就被设定成仅在当前文件内有效
>
> 也就是说，当多个文件中有同名的`const`变量时，其实等同于在不同文件中分别定义了单独的变量，互不干扰
>
> ----
>
> **多个文件中共享`const`对象，必须在定义之前加`extern`关键字**
>
> 有时候，有一种`const`常量，它的初始值不是常量表达式，但又想在多个文件中共享，即一个文件中定义`const`，多个文件中声明并使用它
>
> 解决办法就是不管声明还是使用，都加上`extern`关键字
>
> ```c++
> //file_1.cc定义并初始化了一个常量，该常量可被其他文件访问
> extern const int bufSize = fcn();
> //file_1.h头文件
> extern const int bufSize;//与file_1.cc定义的是同一个
> ```

**`const`引用**

把引用绑到一个`const`对象上，我们**习惯上**称作**对常量的引用**（严格来说，并不存在常量引用）

```c++
const int i = 42;
const int &ci = i;//引用和对象都是常量
ci = 42//错误，ci是对常量的引用
int &ci2 = i;//错误，试图让一个非常量引用指向一个常量对象
```

因为不允许直接为`i`赋值，当然也就不允许通过引用来改变`i`

> **初始化和对`const`的引用**
>
> 之前提过，引用的类型必须与它想引用的对象的类型一致。但凡事都有例外。第一种例外就是初始化<u>常量引用</u>时，允许用任意表达式作为初始值（只要这俩类型一样）
>
> ```c++
> int i = 42;
> const int &ci = i;//允许将一个常量引用绑到一个普通变量上
> const int &ci2 = 42;//正确，ci2 是一个常量引用
> const int &ci3 = ci * 2;//正确，ci3 是一个常量引用
> int &c4 = ci * 2;//错误，ci4 是一个普通的非常量引用
> ```
>
> 引用一个非`const`的对象
>
> ```c++
> int i = 42;
> int &ci = i;//引用ci绑定对象i
> const int &ci2 = i;//ci2也绑定对象i，但是不允许通过ci2修改i的值
> ci = 0;//i的值修改为0
> ci2 = 0;//错误，ci2 是一个常量引用，不能修改i值
> ```

**指针和`const`**

类似于常量引用，**指向常量的指针不能改变其所指对象的值**。要想存放常量对象的地址，只能使用指向常量的指针

```c++
const double pi = 3.14;//pi是一个常量，值不能改变
double *ptr = &pi;//错误，ptr是一个普通指针
const double *cptr = &pi;//正确，cptr指向常量
*cptr = 42;//错误，不能给*cptr赋值
```
指针的类型必须与所指的对象类型一致，但有两种例外。

第一种例外是允许一个常量指针指向一个非常量对象
```c++
double dval = 3.14;
const double *cptr = &dval;//正确，但是不可以通过cptr改变dval的值
```



> 所谓指向常量的引用或指针，只不过是指针或引用“自以为是”，它们觉得直接指向了常量，所以不自觉得不去改变所值对象的值，而没有规定这个对象不能通过其它途径去改变

**`const`指针**

指针式一个对象而引用不是，允许把指针本身定义成常量

**常量指针**必须初始化，而且一旦初始化完成，它的值（也就是指针里的地址）就不能再改变

```c++
int errNum = 0;
int *const curErr = &errNum;//curErr一直指向errNum
const double pi = 3.14;
const double *const pip = &pi;//pip是一个指向常量对象的常量指针
```

> 解释：离curErr最近的是`const`，意味着`curErr`本身是一个常量对象，声明符中的下一个符号是`*`，意思是`curErr`是一个常量指针，最后，该声明语句的基本数据类型指向一个`int`对象，同理pip是一个常量指针，指向一个双精度浮点型常量

> pip是一个指向常量的常量指针，就意味着，不论pip所指的**对象值**还是pip自己存储的**地址**都不能改变，相反的，curErr可以去修改errNum的值

**顶层`const`**

众所周知，指针是一个对象，那么指针本身是不是常量和所指的对象是不是一个常量就是两个相互单独的问题

> **顶层`const`**：表示指针本身是一个常量
> **底层`const`**：表示指针所指的对象是一个常量
>
> ```c++
> const int *const p = &q;//靠右的const是顶层const，靠左的const是底层const
> const int &r = ci;//用于声明引用的const都是底层const
> ```

**`constexpr`和常量表达式**

> **常量表达式**：值不会改变且编译过程即可得到计算结果的表达式

```c++
const int max_file = 20;//max_file是常量表达式
const int limit_file = max_file + 1;//limit_file是常量表达式
 int get_size = 27;//get—_size不是常量表达式
const int sz = get_size;//sz不是常量表达式
```

> 一个对象（或表达式）是不是常量表达式由它的数据类型和初始值决定
>
> 尽管get_size 的初始值是一个字面值常量，但由于它的数据类型只是一个int 而非const int ，所以它不属于常量表达式，另一方面，尽管sz 本身是一个常量，但它的具体值直到运行时才能获取到，所以不是常量表达式

> **`constexpr`变量**：
>
> 在一个复杂系统中，很难分辨一个初始值到底是不是常量表达式，因为对象的定义和使用根本就是两回事
>
> 因此，C++11新规，允许将变量声明为`constexpr`类型，以便编译器来验证变量的值是否是一个常量表达式，声明为`constexpr`的变量一定是一个常量，并且必须用常量表达式初始化
>
> ```c++
> constexpr int mf = 20;
> constexpr int limit = mf + 1;
> ```
>
> 一般来说，如果我们认定变量是一个常量表达式，就把它声明为`constexpr`类型

**指针和`constexpr`**

必须声明一点，在`constexpr`声明中定义了一个指针，限定符`constexpr`仅对指针有效，与指针所指的对象无关

```c++
const int *p = nullprt;//p是一个指向整数常量的指针
constexpr int *q = nullptr;//q是一个指向整数的常量指针
```

> p和q的类型不同，p是一个指向常量的指针，而q是一个常量指针，其中的关键在于`constexpr`把它所定义的对象置为了顶层`const`
>
> 而且，`constexpr`指针也可以指向一个非常量

### 处理类型

**类型别名**（type alias)

就是一个名字，和某种类型是同义词，它可以让复杂的类型名字变简单，还有助于理解程序员使用该类型的真实目的

> **定义**类型别名
>
> 1. 传统方法是使用关键字`typedef`
> ```c++
> typedef double wages;//wages是double的同义词
> typedef wages base,*p;//base是double的同义词，p是double*的同义词
> ```
> 2. 新规，使用别名定义
> ```c++
> using SI = Sales_item;//SI是Sales_item的同义词
> ```

> 类型别名和类型的名字**等价**，只要是类型的名字出现的地方，就能使用类型别名
>
> ```c++
> wages hourly,weekly;//等效于 double hourly,weekly;
> SI item;//等效于 Sales_item item;
> ```

**指针、常量和类型别名**

```c++
typedef char *pstring;
const pstring cstr = 0;//cstr是指向char的常量指针
const pstring *ps;//ps是一个指针的指针，它的对象是一个指向char的常量指针
```

> 上述两条声明语句的基本数据类型都是`const pstring`，和过去一样，`const`是对给定类型的修饰。`pstring`实际上就是指向char的指针，因此`const pstring`就是指向char的指针，而非指向char常量的指针
>
> 遇到一条使用类型别名的声明语句，人们总是错误地尝试把类型别名替换成它本来的样子，来理解语句的含义：
>
> ```c++
> const char *cstr = 0;//这是错误理解
> ```
>
> 在强调一遍，这是错误理解。声明语句中用的`pstring`，其基本数据类型是指针。可是重新理解的时候，数据类型变成了`char`，`*`变成了声明符的一部分。前后两种含义截然不同，前者声明了一个指向char的常量指针，改写之后的声明了一个指向const char的指针

**`auto`类型说明符**

让编译器通过初始值，替我们分析变量的类型

复合类型、常量和auto

> 首先，引用实际上是用的它的值
>
> ```c++
> int i = 0 ,&r = i;
> auto a = r;//a是一个整数
> ```
>
> 其次，auto一般会忽略顶层const，同时底层const会被保留下来
>
> ```c++
> const int ci = i,&cr = ci;
> auto b = ci ;//b是一个整数（ci的顶层const特性被忽略掉了）
> auto c = cr ;//c是一个整数（cr是ci的别名，ci本身是一个顶层const）
> auto d = &i;//d是一个指向整数的指针（&取地址符）
> auto e = &ci;//e是一个指向整数常量的指针（对常量对象取地址是一种底层const）
> ```
>
> 如果希望是一个顶层const
>
> ```c++
> const auto f = ci;//ci是int，f是const int
> ```
>
> 还可应用引用
>
> ```c++
> auto &g = ci;//g是一个整型引用，绑定到ci
> auto &h = 42;//错误：不能为非常量引用绑定字面值
> const auto &j = 42;//正确，可以为常量引用绑定字面值
> ```

**decltype类型指示符**

