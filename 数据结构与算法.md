# 第Ⅰ部分 算法初识

**计算机没什么用，他们只会告诉你答案。——巴勃罗·毕加索**

计算机科学的本质之一就是算法研究。利用计算机解决实际问题，首先会选择一个合适的数学模型，来抽象出问题的本质特征，然后就是寻找一种算法，作为问题的解法。用什么方法来设计算法，如何判定一个算法的性能，设计的算法用多少运行时间和存储内存，这些问题是设计软件时所必须考虑的。算法性能的好坏也直接影响到软件性能的优劣。

**什么是算法？**

通俗而言，算法就是解题的方法和步骤。

**算法有什么特征？**

1. 输入（Input）
2. 输出（Output）：一个算法必须有输出，不然没有什么意义来设计算法
3. 确定性（Definiteness）：每个步骤是明确定义的
4. 可行性（Effectiveness）
5. 有穷性（Finiteness）：执行有限步骤就终止

**算法有什么基本要素？**

- 对数据对象的运算和操作
> 算术运算、逻辑运算、关系运算和数据传输
- 算法的控制结构
> 顺序、选择和循环

算法可以用自然语言、流程图、N-S流程图和伪代码描述

**Data Structures + Algorithms  = Programs. ——Niklaus Wirth（1984年度图灵奖得主）**

**要怎样看待一个算法的好坏？**

一个问题采用正确的方法，那么解决的速度会很快。算法同理，一个问题采用正确的算法去执行程序，速度也必然应该很快。

那么评价一个算法的好坏，主要看它花费的CPU时间的多少和需要占用的内存大小，也就是**时间效率**和**空间效率**（这里就不讨论详细原因，有兴趣可看邓俊辉老师的[解释](https://www.bilibili.com/video/BV1hJ411S7wU?p=4&vd_source=4fe602163e123a42d52b1a7672e94c9a)）

评价算法有很多原则，正确性、可读性、简明性、健壮性和可靠性，但这些都不重要，the most important 是**<u>效率</u>**

算法的复杂度就是效率的尺子，陶渊明讲"好读书，不求甚解"，同样，在忽略其他因素时，当输入不断增大的时候，我们把目光放长远，关注的是趋势，不再纠结短暂的速度快慢，这就是大名鼎鼎的**渐进分析法**。尺子上的刻度就是运行时间的上界（big O 记号）、下界（Ω 记号）或者 准确界（ↀ 记号）三种表示方法

> O(1)<O(log<sub>2</sub><sup>n</sup>)<O(n)<O(nlog<sub>2</sub><sup>n</sup>)<O(n<sup>2</sup>)<O(n<sup>3</sup>)
> 
> O(2<sup>n</sup>)<O(n!)<O(n<sup>n</sup>)

**常见问题**

问题是越来越多，算法也是越来越多，但它们都是由一些求解基本问题的基本算法组合而成，下面是一些基本问题

1. 排序问题：插入排序、选择排序、归并排序、桶排序...
2. 查找问题：顺序查找、二分法查找、哈希查找...
3. 图问题：深度优先算法、广度优先算法、最短路径算法...
4. 组合问题：计算领域最难的问题，旅行商问题是典型
5. 几何问题：凸包问题和最近点对问题是典型
6. 数值问题：求解方程组、定积分、函数最大值...
7. 其他常见问题：最大子段和问题、找钱问题、背包问题、多段最短路径问题、n皇后问题、假币问题、（字符）串处理问题

**算法设计**

首先明确一点，并不是所有的问题都有算法。有的问题研究可行，就有对应的算法；有些问题不能说明可行，就没有对应的算法，但不是说这类问题没有结果。

> 例如，猜想问题，有结果，然而截至目前还没有算法

算法分为**数值计算算法**和**非数值计算算法**

> 数值计算算法
>
> 顾名思义，主要用于科学计算，像什么解方程的根、求积分和建立数学模型等
>
> 1. 迭代法，求解方程近似根
> 2. 插值法
> 3. 差分法，求解微分方程的近似解
> 4. 归纳法
> 5. 递推法
> 6. 减半递推技术
> 7. 递归法
>
> 非数值计算算法
>
> 1. 穷举法
> 2. 分治算法，问题不断化为更小的问题
> 3. 贪心算法，最优解
> 4. 动态规划算法，用填表的方法保存计算的中间结果
> 5. 回溯算法，跳过大量无需测试的数据，快速得解
> 6. 分支限界算法

# 第Ⅱ部分 算法

## 递归算法

>  递归算法是一种通过自身调用自身或间接调用自身来达到问题解决的算法。

递归的**基本思想**是把一个要求解的问题划分成多个规模更小的子问题，这些子问题应该与原问题保持同一类型，然后用同样的方法求解规模更小的子问题。

简单总结，递归具有以下**三个特性**：

1. 问题能被划分成一个或多个结构相同、规模更小的问题。相邻两次重复之间有联系，通常较小问题的输出是较大问题的输入
2. 递归调用的次数有限
3. 有结束递归的条件。当达到限制条件是，能直接得解

**Example**

求阶乘问题。

> 要求解 `n!` 
>
> 首先要转化问题`n! = n * (n-1)!`，求解`(n-1)!`
>
> 然后划分小问题 `(n-1)! = (n-1) * (n-2)!`,求解`(n-2)!`
>
> 有规律的递减，直到`1!`结束
>
> 当得到`n=1`的解之后，再返回来，不断处理
>
> 直到得到规模为`n`的问题的解为止
>
> 递归在实现时，自身调用自身，层层向下进行，而求解原问题的解时次序正好相反
>
> ![阶乘](https://github.com/Lconfident/Pictures/blob/main/%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3/%E9%98%B6%E4%B9%98%E9%80%92%E5%BD%92.png)

