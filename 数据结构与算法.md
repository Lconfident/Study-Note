# 第Ⅰ部分 到底什么是算法？

**计算机没什么用，他们只会告诉你答案。——巴勃罗·毕加索**

计算机科学的本质之一就是算法研究。利用计算机解决实际问题，首先会选择一个合适的数学模型，来抽象出问题的本质特征，然后就是寻找一种算法，作为问题的解法。用什么方法来设计算法，如何判定一个算法的性能，设计的算法用云少运行时间和存储内存，这些问题是设计软件时所必须考虑的。算法性能的好坏也直接影响到软件性能的优劣。

**什么是算法？**

通俗而言，算法就是一组完成任务的指令。

**算法有什么特征？**

1. 输入（Input）
2. 输出（Output）：一个算法必须有输出，不然没有什么意义来设计算法
3. 确定性（Definiteness）：每个步骤是明确定义的
4. 可行性（Effectiveness）
5. 有穷性（Finiteness）：执行有限步骤就终止

**算法有什么基本要素？**

- 对数据对象的运算和操作
> 算术运算、逻辑运算、关系运算和数据传输
- 算法的控制结构
> 顺序、选择和循环

算法可以用自然语言、流程图、N-S流程图和伪代码描述

**Data Structures + Algorithms  = Programs. ——Niklaus Wirth（1984年度图灵奖得主）**

**要怎样看待一个算法的好坏？**

​	这里提一下二分查找，其输入是有序的元素列表，如果要找的元素包含在列表中，二分查找返回其位置；否则返回null

> 这里的示例说明了二分查找的工作原理。我随便想一个1~100的数字。
> 你的目标是以最少的次数找到我的数字。你每次猜测后，我会说小了、大了或对了。
>
> 假如你从1开始依次往上猜，猜测的过程会很长很长，这就是简单查找，更准确的说法是傻找。每次都只能排除一个数字。如果我想的是99，你得猜99次才能猜到！
>
> 下面就是一种更好的猜法。从50开始猜，小了，但排除了一半的数字，至此，你知道1~50都小了。接下来，你猜75，大了，那余下的数字又排除了一半！再接下来，你猜63（50和75中间的数字）...这就是二分查找。不管我心里想的是哪个数字，你在7次之内都可以猜到，因为每次猜测都能排除很多数字！
>
> 一般来说，对于包含有n个元素的列表，用二分查找最多需要log<sub>2</sub><sup>n</sup>步，而简单查找却最多需要n步。

​	每次介绍算法时，我们都将讨论其运行时间。一般来说，应选择**效率**最高的算法，以最大限度地减少运行时间或占用空间。（有兴趣可看邓俊辉老师的[解释](https://www.bilibili.com/video/BV1hJ411S7wU?p=4&vd_source=4fe602163e123a42d52b1a7672e94c9a)）

​	回到之前的二分查找，使用它究竟可以节省多少时间呢？简单逐个地检查数字，如果列表有100个数字，最多需要猜100次。如果列表有40亿个数字，最多需要猜40亿次。换言之，最多需要猜测的次数与列表长度相同，这被称为**线性时间（linear time）**。

​	二分查找则不同，如果列表有100个数字，最多需要猜7次；如果列表有40亿个数字，最多需要猜32次。厉害吧？二分查找的运行时间为对数时间或（log时间）

​	运行时间是算法的尺子，那尺子上的刻度就是**大O表示法**，指出了算法究竟有多快。

> 上界（大 O 记号）、下界（Ω 记号）或者 准确界（ↀ 记号）三种表示方法
>
> O(1)<O(log~2~^n^)<O(n)<O(nlog~2~^n^)<O(n^2^)<O(n^3^)
> O(2^n^)<O(n!)<O(n^n^)

**算法的运行时间以不同的速度增加**

​	Tom要为NASA编写一个查找算法，这个算法要在火箭即将登陆火星前开始执行，帮助计算着陆点。这个示例表明，两种算法的运行时间呈现不同的增速。Tom需要做出决定，是使用二分查找还是简单查找。使用的算法必须快速而准确。一方面，二分查找速度更快，Tom必须在10s之内找到着陆地点，否则火箭将偏离方向。另一方面，简答查找编写起来更容易，因此出现Bug的可能性更小。Tom不希望关键时刻掉链子！为了确保万无一失，他决定计算两种算法在列表有100个元素的情况下各自需要的时间。

​	假设检查一个元素需要1毫秒。使用简单查找时，Tom必须查找100个元素，也就是需要100ms才能查找完毕。而使用二分查找时，只需检查7个元素（log<sub>2</sub><sup>100</sup>大约为7），因此需要7ms就能查找完毕。然而，实际要查找的列表有10亿个元素，这种情况下，Tom测试了一下二分查找，运行时间为30ms。他心想，二分查找的速度大约为简单查找的15倍，因为列表包含100个元素时，简单查找需要100ms，二分查找需要7ms。因此，列表包含10亿个元素时，简单查找需要30*15=450ms，完全符合在10s内查找完毕的要求。Tom决定使用简单查找，这真的是个正确的选择吗？

​	不是。实际上，Tom错了，而且错得十分离谱。列表包含10亿个元素时，简单查找需要10亿ms，相当于11天！为什么呢？因为**二分查找和简单查找的运行时间的增速不同。**也就是说，随着元素数量的增加，二分查找需要的额外时间并不多，而简单查找需要的额外时间却很多。Tom以为二分查找是简单查找的15倍，这不对：列表包含10亿个元素时，为3300万倍。有鉴于此，仅知道算法需要多长时间才能运行完还不够，还需要知道运行时间如何随列表增长而增加。这就是大名鼎鼎的**渐进分析法**。大O表示法指出了算法有多快。简答查找是O(n)。单位秒呢？没有——大O表达法**让你比较操作数，它指出了算法运行时间的增速**。

**大O表示法指出了最糟糕情况下的运行时间**

​	假设你试图用简单查找在电话簿上的人。你知道，简单查找的运行时间为O(n)，这意味着最糟糕情况下，必须查找每个条目。如果查找的认识Alen——电话簿里的第一个人，一次就能找到，无需查看每个条目。考虑到一次就找到Alen，请问这种算法的运行时间是O(n)还是O(1)呢？

​	简单查找的运行时间总是O(n)。查找Alen时，一次就找到了，这是最佳情况，但大O表示法说的是最糟糕的情形。在最糟糕的情形下，必须查看电话簿的每个条目，对应的运行时间为O(n)。这是一个保证——你知道简单查找运行时间不可能超过O(n)。

> 一些常见的大O运行时间
>
> 下面从快到慢列出经常遇到的5种大O运行时间
>
> - O(log<sub>2</sub><sup>n</sup>)，也叫对数时间，包括二分查找
> - O(n)，也叫线性时间，包括简单查找
> - O(n*log<sub>2</sub><sup>n</sup>)，包括较快的快速排序
> - O(n<sup>2</sup>)，包括较慢的选择排序
> - O(n!)，包括旅行商问题——一种非常慢的算法

这里做一个小小的总结。

- 算法的速度并非时间，而是操作数的增速
- 谈论算法的速度时，我们说的时随着输入的增加，其运行时间将以什么样的速度增加
- 算法的运行时间用大O表示法表示
- O(log<sup>n</sup>)比O(n)快，当搜索的元素越多时，前者比后者快得越多
- 一般O(log<sup>n</sup>)是指以2为底的O(log<sub>2</sub><sup>n</sup>)

**常见问题**

问题是越来越多，算法也是越来越多，但它们都是由一些求解基本问题的基本算法组合而成，下面是一些基本问题

1. 排序问题：插入排序、选择排序、归并排序、桶排序...
2. 查找问题：顺序查找、二分法查找、哈希查找...
3. 图问题：深度优先算法、广度优先算法、最短路径算法...
4. 组合问题：计算领域最难的问题，旅行商问题是典型
5. 几何问题：凸包问题和最近点对问题是典型
6. 数值问题：求解方程组、定积分、函数最大值...
7. 其他常见问题：最大子段和问题、找钱问题、背包问题、多段最短路径问题、n皇后问题、假币问题、（字符）串处理问题

**算法设计**

首先明确一点，并不是所有的问题都有算法。有的问题研究可行，就有对应的算法；有些问题不能说明可行，就没有对应的算法，但不是说这类问题没有结果。

> 例如，猜想问题，有结果，然而截至目前还没有算法

算法分为**数值计算算法**和**非数值计算算法**

> 数值计算算法
>
> 顾名思义，主要用于科学计算，像什么解方程的根、求积分和建立数学模型等
>
> 1. 迭代法，求解方程近似根
> 2. 插值法
> 3. 差分法，求解微分方程的近似解
> 4. 归纳法
> 5. 递推法
> 6. 减半递推技术
> 7. 递归法
>
> 非数值计算算法
>
> 1. 穷举法
> 2. 分治算法，问题不断化为更小的问题
> 3. 贪心算法，最优解
> 4. 动态规划算法，用填表的方法保存计算的中间结果
> 5. 回溯算法，跳过大量无需测试的数据，快速得解
> 6. 分支限界算法

# 第Ⅱ部分 了解算法...

**旅行商**

​	阅读到这，你可能认为不可能存在运行时间按为O(n!)的算法。让我来证明你错了！这是一个计算机科学领域非常著名的旅行商问题，其计算时间增加得非常快，而那些非常聪明的人都认为它没有改进空间。

​	有一位旅行商。他需要前往5个城市。这位旅行商（姑且称之为Opus吧）要前往5个城市，同时要确保旅程最短，为此，可考虑前往城市的各种可能顺序。对于每种顺序，他都计算总旅程，再挑选出旅程最短的路线。5个城市有120次操作。涉及6个城市时，需要720次操作（有720种排列方式）。涉及7个城市时，需要5040次操作！推广一下，涉及n个城市时，需要执行n！（n的阶乘）次操作才能计算出结果。因此运行时间为O(n!)，即阶乘时间。除非涉及的城市很少，否则需要执行非常多的操作。如果涉及的城市数超过100，根本不能在合理的时间内计算出来——等你计算出结果来，太阳都没了。

​	这种算法很糟糕！Oups应使用别的算法，可他别无选择。这是计算科学领域亟待解决的问题之一。对于这个问题，目前还没有找到更快的算法，我们只能去找近似答案。

## 选择排序

**内存的工作原理**

​	假如你要去看演出，需要将东西寄存。寄存处有一个柜子，柜子有很多抽屉。每个抽屉可以放一样东西，你有两样东西需要寄存，因此要了两个抽屉。你将两样东西存放在抽屉里。现在你就可以去看演出了！这大致就是计算机内存的工作原理。

​	计算机就像是很多抽屉的集合体，每个抽屉都有地址。需要将数据存储到内存时，你请求计算机提供存储空间，计算机给你一个存储地址。需要存储多项数据时，有两种基本方式——数组和链表。它们差别很大。

## 数组和链表

 	有时候，你需要在内存中存储一系列元素。假如你要编写一个管理代办事项的应用程序，为此需要将这些代事项存储到内存中。应使用数组还是链表呢？鉴于数组更容易掌握，我们先将待办事项存储到数组中。使用数组就意味着所有的待办事项在内存中都是相连的（紧靠在一起的）。

​	现在假设你要添加第4个待办事项，但是后面的那个抽屉放着别人的东西！这就像你与朋友去看电影，找到地方就坐后又来了一位朋友，但原来坐的地方没有空的位置，只能再找一个可坐的座位。在这种情况下，你要求计算机重新分配一块可以容纳4个代办事项的内存，再将所有的待办事项移到那里。

​	如果又来了一位朋友，而当前的地方也没有空位，你们就得再次转移！真的麻烦！同样，在数组中添加新元素也可能很麻烦。如果没有了空间，就得一刀内存的其他地方，因此添加新元素得速度会很慢。一种办法就是''预留座位"：也就是说当前只有3个待办事项，但是我请求计算机给10个待办事项的位置，以防需要添加待办事项，只要它不超过10个，就无需转移。这似乎是一个不错的措施，但你应该明白，它存在以下两个缺点：

- 你额外请求的位置可能根本用不到，这将浪费内存。你不用，别人也用不了。
- 待办事项超过10个后，你还得转移。

面对这种问题，可使用**链表**来解决

**链表**

- 链表中的每个元素可存储在内存的**任何地方**。
- 链表中的每个元素都存储了**下一个元素的地址**，从而使一系列随机的内存地址串在一起。

​	这就如同寻宝游戏。你前往第一个地址，那里有一张纸条写着"下一个元素的地址是123"。因此，你前往地址123，那里又有一张纸条，写着"下一个元素的地址是847"，以此类推。在链表中添加元素很容易：只需将其放入内存，并将其地址存到前一个元素中。

​	使用链表时，根本不需要移动元素。这还可避免另一个问题。假如你与五位朋友去看一部很火的电影。你们六个人想坐在一起，但看电影的人多，没有六个一起的座位。数组只能说"电影看不了"；而链表却说"我们六个分开坐"，因此，只要有足够的内存空间，就有能力为链表分配内存。链表的优势在于插入元素方面，那数组的优势又是什么呢？

**数组**

## 递归算法

>  递归算法是一种通过自身调用自身或间接调用自身来达到问题解决的算法。

递归的**基本思想**是把一个要求解的问题划分成多个规模更小的子问题，这些子问题应该与原问题保持同一类型，然后用同样的方法求解规模更小的子问题。

简单总结，递归具有以下**三个特性**：

1. 问题能被划分成一个或多个结构相同、规模更小的问题。相邻两次重复之间有联系，通常较小问题的输出是较大问题的输入
2. 递归调用的次数有限
3. 有结束递归的条件。当达到限制条件是，能直接得解

**Example**

求阶乘问题。

> 要求解 `n!` 
>
> 首先要转化问题`n! = n * (n-1)!`，求解`(n-1)!`
>
> 然后划分小问题 `(n-1)! = (n-1) * (n-2)!`,求解`(n-2)!`
>
> 有规律的递减，直到`1!`结束
>
> 当得到`n=1`的解之后，再返回来，不断处理
>
> 直到得到规模为`n`的问题的解为止
>
> 递归在实现时，自身调用自身，层层向下进行，而求解原问题的解时次序正好相反
>
> ![阶乘](https://github.com/Lconfident/Pictures/blob/main/%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3/%E9%98%B6%E4%B9%98%E9%80%92%E5%BD%92.png)

