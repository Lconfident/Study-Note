## 开始

### 导学

**计算机系统**
  - 计算机系统由硬件、软件组成 

  - 指令系统是硬件和软件的界面

  > * 机器硬件能够识别的语言（机器语言）的集合
  >
  > * 它是软件和硬件的主要界面 



> **计算机语言**：程序员与计算机沟通的语言

**计算机语言的级别**

* 二进制代码构成的机器语言

  > * 计算机能识别的是机器语言
  > * 机器语言指令是由 0 和 1 编码的
  > * 例如： 加法指令可能是`0001`

* 使用助记符的汇编语言

> * 将机器指令映射为助记符 
> *  如 ADD、SUB、mov 等
> *  抽象层次低，需要考虑机器细节

* 使用类似英语单词和语句的高级语言

> *  关键字、语句容易理解
> * 有含义的数据命名和算式
> * 抽象层次较高
> *  例如，算式：a+b+c/d
> * 屏蔽了机器的细节
> * 例如，这样显示计算结果：cout<

**计算机软件** 

* 是一系列按照特定顺序组织的计算机数据和指令的集合
* 一般来讲软件被划分为系统软件、应用软件和介于这两者之间的中间件
* 软件包含程序和文档

**计算机程序** 

* 指令的序列；
* 描述解决问题的方法和数据

**C++支持的程序设计方法**

* 面向过程的程序设计方法
* 面向对象的程序设计方法
* 泛型程序设计方法

**C++程序的开发过程**

* 算法设计 
* 源程序编辑
* 编译
* 连接
* 运行调试 

**信息在计算机中的表示与存储**

* 计算机中的数据用二进制表示
* 逻辑数据、字符数据用二进制编码表示

信息的存储单位

- 位(bit，b)：数据的最小单位，表示一位二进制信息；
- 字节(byte，B)：八位二进制数字组成(1 byte = 8 bit)；
- 千字节 1 KB = 1024（2^10^） B；
- 兆字节 1 MB = 1024 K； 
- 吉字节 1 GB = 1024 M。

**计算机的基本功能**： 

- 算术运算
- 逻辑运算

计算机中信息：

- 控制信息——指挥计算机操作

- 数据信息——计算机程序加工的对象

- > **数据信息** 包括 **数值信息** 和 **非数值信息**
  >
  > 数值信息：**定点数** 和 **浮点数**
  >
  > 非数值信息：**字符数据** 和 **逻辑数据**

### 面向对象

**对象** 

* 一般意义上的对象：现实世界中实际存在的事物。
* 面向对象方法中的对象：程序中用来描述客观事物的实体。 

**抽象与分类**

* 分类依据的原则——抽象；
* 抽象出同一类对象的共同属性和行为形成类；
* 类与对象是类型与实例的关系。

 **封装**

* 隐蔽对象的内部细节；
* 对外形成一个边界；
*  只保留有限的对外接口；
* 使用方便、安全性好。

 **继承** 

* 意义在于软件复用；
* 改造、扩展已有类形成新的类。 

**多态** 

* 同样的消息作用在不同对象上，可以引起不同的行为。

### 程序的开发过程

 **程序** 

1. 源程序： 用源语言写的，有待翻译的程序；
2. 目标程序：源程序通过翻译程序加工以后生成的机器语言程序；
3. 可执行程序：连接目标程序以及库中的某些文件，生成的一个可执行文件；例如：Windows 系统平台上的.EXE 文件。

**三种不同类型的翻译程序**

* 汇编程序：将汇编语言源程序翻译成目标程序
* 编译程序：将高级语言源程序翻译成目标程序
* 解释程序：将高级语言源程序翻译成机器指令，边翻译边执行

### 计算机的数字系统

计算机的数字系统

- 二进制系统；
- 基本符号：0、1。 

程序中常用的数制： 

| 进制     | 基数 | 进位原则   | 基本符号                                             |
| -------- | ---- | ---------- | ---------------------------------------------------- |
| 二进制   | 2    | 逢二进一   | 0，1                                                 |
| 八进制   | 8    | 逢八进一   | 0，1，2，3，4，5，6，7                               |
| 十进制   | 10   | 逢十进一   | 0，1，2，3，4，5，6，7，8，9                         |
| 十六进制 | 16   | 逢十六进一 | 0，1，2，3，4，5，6，7，8，9，<br />A，B，C，D，E，F |

**R 进制转换为十进制：** 

- 各位数字与它的权相乘，其积相加，

- 例如: 

  (11111111.11)~2~=1×27+1×26+1×25+1×24+1×23+1×22+1×21+1×20+1×2-1+1 ×2-2 =(255.75)10 

**十进制整数转换为 R 进制整数：**

- “除以 R 取余”法。 
- 68~10~＝1000100~2~

**十进制小数→ R 进制小数：**

- “乘 以 R 取整”法。 
- 0.3125~10~ = 0.0101~2~

**十六进制的相互转换:** 

- 1 位八进制数相当于 3 位二进制数；
- 1 位十六进制数相当于 4 位二进制数，
- (1011010.10)~2~ = (<u>001</u> <u>011</u> <u>010</u> .<u>100</u>)~2~ = (132.4)~8~ 
- (1011010.10)~2~ = (<u>0101</u> <u>1010</u> .<u>1000</u>)~2~ = (5A.8)~16~
- (F7)~16~＝(<u>1111</u> <u>0111</u>)~2~ ＝(11110111)~2~

**数据在计算机中的编码表示**

**二进制数的编码表示** 

- 需要解决的问题：负数如何表示？

- 最容易想到的方案： 0：表示“+”号； 1：表示“-”号。 

- 原码

- - 原码的缺点：零的表示不惟一 
  - 进行四则运算时，符号位须单独处理，运算规则复杂。 

- 补码

- - 符号位可作为数值参加运算；
  - 减法运算可转换为加法运算；
  - 0 的表示唯一。 

- 补码的原理

- - 模数：
    n 位二进制整数的模数为 2^n^ ；

    n 位二进制小数的模数为 2。

  - 补数：

    一个数减去另一个数（加一个负数），等于第一个数加第二个数的补数，例 （时钟指针）： 8+(-2)=8+10 ( mod 12 )=6； 

    一个二进制负数可用其模数与真值做加法 (模减去该数的绝对值) 求得其补码， 例（时钟指针）：-2+12=10。

- 补码的计算 

- - 借助于“反码”作为中间码
  -  负数的反码与原码有如下关系： 
  - 符号位不变(仍用 1 表示)，其余各位取反(0 变 1，1 变 0)
    例如： 
    X= - 1100110 
    [X]~原~ =1 1100110 
    [X]~反~ =1 0011001
  - 负数的补码由该数反码的末位加 1 求得。
  - 对补码再求补即得到原码。
  - 正数的反码与原码表示相同，正数的补码与原码相同；
  - 反码只是求补码时的中间码； 

  **实数的浮点表示**

- 计算机中通常采用浮点方式表示小数；

  - 实数 N 用浮点形式可表示为： N=M×2^E^ 
  - E：2 的幂，N：阶码； M：N 的尾数。 

  **字符在计算机中的表示** 

  - 字符在计算机中是通过编码表示的；
  - ASCII 码是一种常用的西文字符编码：用 7 位二进制数表示一个字符，最多可以表示 27=128 个字符；
  - 《GB 18030-2005 信息技术 中文编码字符集》是中国国家标准。 

## 简单程序

每个C++程序有一个或多个函数（**function**)，但必须包含**main函数**，操作系统会通过调用main来运行C++程序。

**一个函数的定义：**

- 返回类型（**return type**）
- 函数名（**function name**)
- 形参列表（**parameter list**）
- 函数体（**function body**)

```c++
int main (){
    return 0;
}
```

> - main的形参列表是空的
> - main函数的返回类型必须是 **int** 
> - 最后一部分是函数体，以左花括号开始，以右花括号结束的语句块

> 类型是程序设计的最基本的概念之一，一种类型不仅定义了数据元素的内容，还定义了这类数据上可以进行的运算。
>
> 程序所处理的数据都保存在变量中，而每个变量都有自己的类型。
> 即<u>v具有类型T</u>或<u>v是一个T类型变量</u>

### 编译、运行程序

* 程序源文件：程序源码存储在一个或多个文件中，程序文件通常称为**源文件**（source file）

### **初识输入、输出**

C++并未定义任何输入、输出（IO）语句，取而代之，包含了一个全面的标准库（standard library）来提供IO机制（以及其他设施）

> **iostream**库：有两个基础类型 **istream** 和 **ostream** ，分别表示输入流和输出流。
>
> 一个流就是一个字符序列，是从IO设备读出或写入IO设备的。
>
> 术语`流`想要表达的是，随着时间的推移，字符是顺序生成或消耗的

**标准输入输出对象**

标准库定义了4个IO对象

> 为了处理输入，我们使用一个名为 **`cin`**（发音为 see-in）的 `istream` 类型的对象，这个对象也被称作**标准输入**

> 为了输出，我们使用一个名为 **`cout`**（发音为see-out）的 `ostream` 类型的对象，此对象也被称作**标准输出**

> 标准库还定义了其他两个 `ostream` 对象，名为 **`cerr`** ,**`clog`**（发音分别是  see-err 和 see-log）
>
> 我们通常用 cerr 来输出警告和错误信息，因此它有被称作**标准错误**（standard error），而 clog 用来输出程序运行时的一般性信息

**一个使用IO库的函数**

>  提示用户输入两个数，然后输出它们的和

```c++
#include <iostream>
int main() {
	std::cout << "Enter two number:" << std::endl;
	int v1 = 0, v2 = 0;
	std::cin >> v1 >> v2;
	std::cout << "The sum of" << v1 << "and" << v2
		<< "is" << v1 + v2 << std::endl;
	return 0;
}
```

> 这个程序开始时在用户屏幕打印
>
> `Enter two numbers`
>
> 然后等待用户输入。如果输入
>
> `3 7`
>
> 然后键入一个回车，则程序产生如下输出：
>
> `The sum of 3 and 7 is 10`

**程序第一行**

> `#include <iostream>`
>
> 告诉编译器我们想要使用**iostream库**。
> 尖括号中的名字（本例是iostream）指出了一个**头文件**（header）。
> 每个使用标准库设施的程序都必须包含相关的头文件。
> 通常情况下，#include指令和头文件写在源文件的开始位置

> > 头文件：指在C/C++编程中，可以写在程序里面，以#include 的形式包含的文件
>
> > 库文件：将一系列的源文件进行编译打包，形成的二进制文件包，其中封装着函数接口，在编程中可以由其它源文件调用。库文件可分为静态库和动态库两种。
>
> > 二者的区别为：
> >
> > 1. 头文件是**文本文件**，是可供阅读的 ；库文件是**二进制文件**，不可直接阅读。
> > 2. 头文件在**编译中**使用；库文件在**链接中**使用。
> > 3. 头文件中是函数或定义的声明，及少量内联函数的使用，一般不包含非静态函数实现；库文件中包含函数的实现。
> > 4. 头文件是手动编写的，库文件是编译生成的。
>
> > 二者也有联系：
> >
> > 1. 虽然没有规定调用库函数必须引用头文件，但一般约定，当调用库函数的时候需要引用接口函数所在的头文件。
> > 2. 一个库文件均有一组头文件与其对应。
> > 3. 库文件和对应头文件应为同一个。
> > 4. 作者必须保证头文件中所声明的函数类型及参数列表，与库文件中的实现是相同的。

**向流写入数据**

> main的函数体第一条语句执行了一个**表达式**（expression），使用了**输出运算符** `<<` 在**标准输出**上打印消息：
>
> `std::cout << "Enter two numbers:" << std::endl;`
>
> <<运算符接受两个运算对象：
>
> 左侧的运算对象必须是一个 `ostream` 库的对象
>
> 右侧的运算对象是要打印的值
>
> 此运算就是要将给定的值写到给定的 `ostream` 对象中，计算结果就是左侧运算对象

> 我们的输出运算符使用了两次<<运算符。
>
> 等价于
>
> (`std::cout << "Enter two numbers:"`)`<< std::endl;` 
>
> 又因为每个运算符的左侧运算对象都是相同的，`std::cout`，我们也可以用两条语句生成相同的输出：
>
> `std::cout << "Enter two numbers:":`
>
> `std:cout << std::endl;`
>
> 第一个输出运算符给用户打印了一条消息。这个消息是一个**字符串字面值常量**（string literal），是用一对双引号包围的字符序列。在双引号中的文本被打印到标准输出。
>
> 第二个运算符打印`endl`，这是一个被称作为**操作符**的特殊值。写入`endl`的效果是<u>结束当前行</u>，并将与设备关联的**缓冲区**（buffer）中的内容刷到设备中。缓冲刷新操作可以保证，到目前为止程序所产生的所有输出都被真正写入输入输出流中，而不是仅停留在内存中等待写入流。

**使用标准库中的名字**

> 这个程序中使用了`std::cout`和`std::endl`，而不是直接的`cout`和`endl`。
>
> 前缀`std::`指出名字`cout`和`endl`是定义在名为**`std`**的**命名空间**（namespace）中的。
>
> 命名空间可以帮助我们避免不经意的名字定义冲突，以及使用库中相同名字导致的冲突。
>
> 标准库所有的名字都命名在命名空间`std`中
>
> 但是通过命名空间使用标准库有一个副作用：
>
> 当使用标准库的一个名字时，必须显式说明我们像使用命名空间`std`中的名字。例如，需要写出`std::count`，通过使用**作用域运算符** `::`来指出我们想使用定义在命名空间`std`中的`cout`。之后会给出一个更简单的访问标准库中名字的方法。

**从流中读取数据**

> 在提示用户输入数据后，我们希望读入用户的输入。首先定义两个名为`v1`和`v2`的变量（variable)来保存输入：
>
> `int v1 = 0, v2 = 0;`
>
> 我们将这两个变量定义为`int`类型，int是一种内置类型，用来表示整数。同时将它们**初始化**（initialize）为0。初始化一个变量，就是在变量创建的同时为它赋予一个值。
>
> 下一条语句是
>
> `std::cin >> v1 >> v2;`
>
> 它读入输入数据。**输入运算符**`>>`与输出运算符类似，它接受一个`istream`作为其左侧运算对象，接受一个对象作为其右侧运算对象。它从给定的`istream`读入数据，并存入给定对象中。
>
> 输入运算符返回其左侧运算对象作为其计算结果。因此等价于
>
> (`std::cin >> v1`)`>> v2;`
>
> 也与上面的例子一样，同样等价于
>
> `std::cin >> v1;`
>
> `std::cin >> v2;`

**完成程序**

> 剩下的就是打印计算机结果了：
>
> `std::cout << "The sum of " << v1 << " and " << v2 << " is " << v1+v2 << std::endl;`

> 这条语句虽然比提示语句更长，但原理上是一样的，它将每个运算对象打印在标准输出上。本例最大的特别之处在于，运算对象并不都是相同类型的值。某些运算对象是字符串字面值常量，其他运算对象是int值。

### 注释简介

**C++注释的种类**

C++有两种注释：

- 单行注释

- > 单行注释以双斜线 `//`开始，以换行符结束。当前行双斜线右侧的所有内容都会被编译器忽略，这种注释可以包含任何文本，包括额外的双斜线

- 界定符注释

- > 这种注释继承自C语言的两个界定符 `/*` 和 `*/` ,可包含处`*/` 外的任意内容

> 注释界定符不能嵌套

### 控制流

#### while语句

> while语句反复执行一段代码，直至给定条件为假为止。

认识几个运算符：

> `<=` : 小于等于运算符
>
> `+=` : 复合赋值运算符
>
> `++` : 前缀递增运算符

#### for语句

```c++
for (int val = 1; val <=10; val++){
    sum += val;
}
```

> 简要描述一下for循环的总体执行过程：
>
> 1. 创建变量val，将其初始化为1
> 2. 检测val是否小于等于10。若ture，执行for循环体；若false，退出循环，继续执行for循环体之后的语句
> 3. 将val的值增加1
> 4. 重复步骤2，，只要条件为真就执行剩余步骤

#### 读取数量不定的输入数据

在前一节中，我们编写了程序实现了1和10这10个整数求和，扩展这个程序很自然的方向是实现对用户输入的一组数求和。

在这种情况下，我们预先不知道要对多少个数求和，这就需要不断读取直至没有新的输入为止。

```c++
#include <iostream>
int main() {
	int sum = 0, value = 0;
	//读取数据直到遇到文件尾，计算所有读入的值的和
	while (std::cin >> value) {
		sum += value;
	}
	std::cout << "Sum is:" << sum << std::endl;
	return 0;
}
```

> 如果我们输入
>
> `3 4 5 6`
>
> 则程序输出
>
> `Sum is: 18`

> `main` 的首行定义了两个名为 `sum` 和 `value` 的 `int` 变量，均初始化为0。我们使用 `value` 保存用户输入的每个数，数据读取操作是在 `while`的循环操作中完成的：
>
> `while (std::cin >> value)`
>
> `while` 循环条件的求值就是执行表达式：
>
> `std::cin >> value`
>
> 此表达式从标准输入读取下一个数，保存在 `value` 中。输出运算符返回其左侧运算对象，在本例中是 `std::cin` ，因此，此循环条件实际上检测的是 `std::cin` 。

> 当我们使用一个 `iostream` 对象作为条件时，其效果是检测流的状态。
>
> 如果流是有效的，即流未遇到错误，那么检测成功。
>
> 当遇到文件结束符或遇到一个无效输入时（例如读入的值不是一个整数）， `iostream` 对象的状态会变为无效。处于无效状态的`iostream`对象会使条件为假。

> 从键盘输入文件结束符：
>
> Windows系统中，输入文件结束符的方法：<kbd>Ctrl</kbd> + <kbd>Z</kbd>,然后按 <kbd>Enter</kbd>
>
> UNIX系统中，输入文件结束符的方法：<kbd>Ctrl</kbd> + <kbd>D</kbd>

#### if 语句

> C++使用 `=` 来赋值，用 `==` 作为相等运算符。

### 类简介

C++特性：如何定义一个数据结构（data structure）来表示数据

C++中可以通过定义一个**类**（class）来定义自己的数据结构

为了使用类，我们需要了解三个事情：

+ 类名是什么？
+ 它是在哪里定义的？
+ 它是支持什么操作？

对于书店程序，我们假定类名为`Sale_item`，头文件`Sale_item.h`中已经定义了这个类

因此，为了使用标准库设施，我们必须包含相关的头文件。类似的，我们也需要使用头文件来访问为自己的应用程序所定义的类。

习惯上，头文件根据其中定义的类的名字来命名。我们通常使用 `.h` 作为头文件的后缀，标准库头文件通常不带后缀。

**Sales_item类**

Sales_Item 类的作用是表示一本书的总销售额、售出册数和平均售价。

> 我们现在不关心这些数据如何存储、如何计算。为了使用一个类，我们不必关心它是如何实现的，只需直到类对象执行什么操作。

> 每个类实际上都定义了一个新的类型，其类型名就是类名。因此，我们的`Sales_item` 类定义了一个名为 `Sales_item` 的类型。
>
> 当我们写下如下语句：
>
> `Sales_item item;`
>
> 是想表达 `item` 是一个 `Sales_item` 类型的对象。我们通常将“一个`Sales_item`类型的对象”简单说成“一个`Sales_item`对象”，或更简单的“一个`Sales_item` ”

> 除了可以定义`Sales_item`类型的变量外，我们还可以：
>
> + 调用一个名为`isbn`的函数从一个`Sales_item`对象中提取ISBN书号
> + 用输入运算符`>>`和输出运算符`<<`读、写`Sales_item`类型的对象
> + 用赋值运算符`=`将一个`Sales_item`对象的值赋予另一个`Sales_item`对象
> + 用加法运算符`+`将两个`Sales_item`对象相加。两个对象必须表示同一本书（相同的ISBN）。加法结果是一个新的`Sales_item`对象，其IBSN与两个运算对象相同，而其总销售额和售出册数则是两个运算对象的对应值之和
> + 使用复合赋值运算符`+=`将一个`Sales_item`对象加到另一个对象上

> 一般而言，类的作者决定了类类型对象上可以使用的所有操作。

**读取`Sales_item`**

> 既然已经知道可以对`Sales_item`对象执行哪些操作，我们就可以编写使用类的程序了。

例如，下面的程序从标准输入读入数据，存入一个`Sales_item`对象中，然后将`Sales_item`内容写回到标准输出：

```c++
#include <iostream>
#include "Sales_item.h"
int main() {
	Sales_item book;
	//读入ISBN号、售出的册数以及销售价格
	std::cin >> book;
	//写入ISBN号、售出的册数、总销售额和平均价格
	std::cout << book << std::endl;
	return 0;
}
```

> 如果输入：
>
> `0-201-70353-x 4 24.99`
>
> 则输出为：
>
> `0-201-70353-x 4 99.96 24.99`
>
> 输出表示我们以每本`24.99`美元的价格售出了4册书，而输出告诉总售出册数为`4`，总销售额为`99.96`美元，而每册书的平均销售价格为`24.99`美元。

> 此程序以两个`#include`指令开始，其中一个使用了新的形式。
>
> 包含来自标准库的头文件时，也应该用尖括号`<>`包围头文件名
>
> 对于不属于标准库的头文件，则用双引号`'' ''`包围

**Sales_item 对象的加法**

下面的例子更有意思，将两个`Sales_item`对象相加：

```c++
#include <iostream>
#include "Sales_item.h"
int main() {
	Sales_item item1,item2;
	std::cin >> item1 >> item2; //交易一对交易记录
	std::cout << item1 + item2 << std::endl; //打印它们的和
	return 0;
}
```

> 如果输入如下内容：
>
> `0-201-78345-x 3 20.00`
>
> `0-201-78345-x 2 25.00`
>
> 则输出：
>
> `0-201-78345-x 5 110 22`

> 此程序开始包含了`Sales_item` 和 `iostream` 两个头文件，然后定义了两个`Sales_item` 对象来保存销售记录 。我们从标准输入读取数据，存入两个对象中，输出表达式完成运算并打印结果。
>
> 两个对象，我们用了一个全新的“和”概念——两个`Sales_item`对象的成员对应相加的结果

### **使用文件重定向**

> 当你测试时，反复从键盘敲入这些销售记录作为程序的输入，是非常枯燥的，大部分的操作系统支持文件重定向的，这种机制允许我们将标准输入和标准输出与命名文件关联起来：
>
> `$ addItems <infile> outfile`
>
> 假定`$`是操作系统提示符，我们的加法程序已经编译为名为`addItems.exe` 的可执行文件（在UNIX中是`addItem`），则上述命令会从一个名为`infile`的文件读取销售记录，并将输出结果写入到一个名为`oufile`的文件中，这两个文件都位于当前目录中

**初识成员函数**

将两个`Sales_item`对象相加的程序相加的程序首先应该检查两个对象是否具有相同的ISBN，方法如下：

```c++
#include <iostream>
#include "Sales_item.h"
int main() {
	Sales_item item1,item2;
	std::cin >> item1 >> item2; //交易一对交易记录
	//首先检查它们是否表示相同的书
	if (item1.isbn() == item2.isbn()) {
		std::cout << item1 + item2 << std::endl;
		return 0;//表示成功
	}
	else {
		std::cout << "Data must refer to same ISBN"
			<< std::endl;
		return -1;//表示失败
	}
}
```

**什么是成员函数**

> 这个`if`语句的检测条件
>
> `item1.isbn() == item2.isbn()`
>
> 调用名为`isbn`的成员函数（member function）。
>
> 成员函数是定义为<u>类的一部分</u>的函数，有时也叫做**方法**（method）

> 我们通常以一个类对象的名义来调用成员函数。
>
> 例如，上述相等表达式左侧运算对象的第一部分
>
> `item1.isbn()`
>
> 使用点运算符`.`来表达我们需要”名为`item1`的对象的`isbn`成员，其左侧必须是一个类的对象，右侧必须是该类的一个成员名，运算结果就是指定对象的指定成员
>
> 当用点运算符`.`访问一个成员函数时，通常调用该函数，我们使用**调用运算符**`()` 来调用一个函数，调用运算符是一对圆括号，里面放置实参（arguement）列表（可能为空）。成员函数`isbn()` 并不接受参数，因此为：
>
> `item1.isbn()`
>
> 调用名为`item1`的对象的成员函数`isbn`，此函数返回`item1`中保存ISBN书号

### 书店程序

现在我们来写一个完整的程序，需要从一个文件中读取销售记录，生成每本书的销售报告，显示售出册数、总销售额和平均售价。我们假定每个ISBN书号的所有销售记录在文件中式聚集在一起保存的。

